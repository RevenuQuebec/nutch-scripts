#!/bin/sh

MUST_REMAIN_SPACE=500000 # 500 Mb
SCRIPTS_DIR=`dirname "${0}"`
CRAWL_SCRIPT=$SCRIPTS_DIR/crawl
REINDEX_SCRIPT=$SCRIPTS_DIR/reindex
BACKUPS_DIR=$HOME/backups

do_core() {
    CRAWLDB_DIR=$HOME/crawl-${1}
    CRAWLDB_SIZE=`du --max-depth=0 $CRAWLDB_DIR | awk '{print $1}'`
    SPACE_LEFT=`df -k $BACKUPS_DIR | tail -1 | awk '{print $4}'`
    REMAINING_SIZE=$(($SPACE_LEFT - $CRAWLDB_SIZE))

    BACKUP_OUT_LOG=$LOGS_DIR/${DATE}-OUT-backup-${1}.log
    BACKUP_ERR_LOG=$LOGS_DIR/${DATE}-ERROR-backup-${1}.log
    CRAWL_OUT_LOG=$LOGS_DIR/${DATE}-OUT-crawl-${1}.log
    CRAWL_ERR_LOG=$LOGS_DIR/${DATE}-ERROR-crawl-${1}.log
    REINDEX_OUT_LOG=$LOGS_DIR/${DATE}-OUT-reindex-${1}.log
    REINDEX_ERR_LOG=$LOGS_DIR/${DATE}-ERROR-reindex-${1}.log

    if [ $REMAINING_SIZE -le $MUST_REMAIN_SPACE ]; then
        echo "${1}: Not enough space to create the backup";
        return 1;
    fi
    # Create a backup of the crawl DB, just in case
    tar -jcf $BACKUPS_DIR/crawl-${1}-$DATE.tar.bz2 -C $HOME crawl-${1} > $BACKUP_OUT_LOG 2> $BACKUP_ERR_LOG;
    RETCODE=$?
    # Check if the backup failed
    if [ $RETCODE -ne 0 ]; then
        echo "${1}: Backup failed";
        rm -rf $BACKUPS_DIR/crawl-${1}-$DATE;
        return 1;
    fi

    # Crawl the website
    $CRAWL_SCRIPT $1 > $CRAWL_OUT_LOG 2> $CRAWL_ERR_LOG;
    RETCODE=$?
    # If an error happened while crawling the website, we must restore the crawldb directory from a backup
    if [ $RETCODE -ne 0 ]; then
        echo "${1}: Crawl failed, restoring backup";
        rm -rf $HOME/crawl-${1};
        tar -C $HOME -jxf $BACKUPS_DIR/crawl-${1}-$DATE.tar.bz2
        mv $BACKUPS_DIR/crawl-${1}-$DATE $HOME/crawl-${1};
        return 1;
    else
        # Remove old segments
        cd $CRAWLDB_DIR/segments && find . -maxdepth 1 -ctime +8 -exec rm -rf '{}' \;

        # Reindex all pages
        $REINDEX_SCRIPT $1 > $REINDEX_OUT_LOG 2> $REINDEX_ERR_LOG
        RETCODE=$?

        # Check if reindexation failed
        if [ $RETCODE -ne 0 ]; then
            echo "${1}: Reindexation failed";
            return 1;
        fi
    fi
}

check_status() {
    RETCODE=$?;
    if [ $RETCODE -ne 0 ]; then
        exit $RETCODE
    fi
}

cleanup() {
    # The Hadoop tmp directory can take all available space
    HADOOP_TMP_DIR=/tmp/hadoop-$USER
    if [ -e "$HADOOP_TMP_DIR" ]; then
        rm -rf $HADOOP_TMP_DIR;
    fi
}

LOGS_DIR=$1
BACKUPS_DIR=$2
if [ "$1" = "" ] || [ "$2" = "" ]; then
    echo "You must provide the path to the logs and backups directories (ex: ./search-cron ./logs ./backups)"
else
    if [ ! -e $LOGS_DIR ]; then
        mkdir -p $LOGS_DIR; check_status;
    fi
    if [ ! -e $BACKUPS_DIR ]; then
        mkdir -p $BACKUPS_DIR; check_status;
    fi

    DATE=`date +\%Y-\%m-\%d-\%H\%M`

    cleanup;
    do_core rq-fr; cleanup;
    do_core rq-en; cleanup;

    # Delete empty log files
    find $LOGS_DIR -type f -size 0 -exec rm -f '{}' \;
fi
